<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>FrameX — Draw • BCs • q-Loads • End Releases • Solve • Stress Panel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
  <style>
    :root { --pad:18px; --canvas-w:980px; --canvas-h:560px; --panel-w:380px; }
    body { background:#f6f7fb; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; margin:20px; }
    h2 { margin:0 0 10px; }
    .row { display:flex; gap:16px; align-items:flex-start; flex-wrap:wrap; }
    .col { background:#fff; border:1px solid #ddd; border-radius:12px; padding:var(--pad); }
    .controls { display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-bottom:10px; }
    button, select, input[type="number"], input[type="text"] {
      height:32px; padding:0 10px; border:1px solid #bbb; border-radius:8px; background:#eee; font-size:14px; color:#333;
    }
    button { cursor:pointer; }
    button.primary { background:#eee; color:#333; border-color:#bbb; }
    button.ghost   { background:#eee; color:#333; border-color:#bbb; }
    button.active  { background:#4b5563; color:#fff; border-color:#4b5563; }

    .stack { display:flex; flex-direction:column; gap:8px; }
    #wrap { position:relative; width:var(--canvas-w); height:var(--canvas-h); background:#fff; border:1px solid #ccc; border-radius:8px; }
    canvas { position:absolute; inset:0; }
    #base { z-index:1; }
    #overlay { z-index:2; pointer-events:auto; cursor:crosshair; }

    .panel { width:var(--panel-w); }
    .list { font-size:13px; max-height:220px; overflow:auto; border:1px dashed #ddd; padding:8px; border-radius:8px; }
    .hint { color:#666; font-size:12px; }
    .mode { font-weight:600; }
    .swal2-popup { font-size:12px !important; width:auto !important; min-width:360px !important; }
    .swal2-input, .swal2-select { font-size:12px !important; height:28px !important; }

    #stressPanelBlock { display:none; }
    #stressPanel { width:100%; height:260px; position:static; border:1px solid #ccc; border-radius:8px; }
  </style>
</head>
<body>
  <h2>FrameX — Draw • BCs • q-Loads • End Releases • Solve • Stress Panel</h2>

  <div class="controls">
    <span class="mode">Mode:</span>
    <button id="btnDraw" class="primary">Draw Members</button>
    <button id="btnSelect" class="ghost">Select/Edit</button>

    <button id="viewGeom" class="ghost">Geometry</button>
    <button id="viewDef" class="ghost">Deflection</button>
    <button id="viewStressPanel" class="ghost">Stress Panel</button>

    <span class="hint">Draw: drag to add a member. Select: drag a node to move; double-click to edit; Delete key removes. Click a member in Stress Panel view to plot σ.</span>
  </div>

  <div class="row">
    <div class="col">
      <div id="wrap">
        <canvas id="base" width="980" height="560"></canvas>
        <canvas id="overlay" width="980" height="560"></canvas>
      </div>
      <div class="controls" style="margin-top:10px; gap:12px;">
        <button id="btnUndo" class="ghost">Undo</button>
        <button id="btnClear" class="ghost">Clear</button>
        <button id="btnExport" class="ghost">Export JSON</button>

        <button id="btnSolve" class="primary">Solve</button>

        <button class="ghost" disabled>Deflection Scale</button>
        <input id="defScale" type="number" step="any" value="1" style="width:80px;">
        <button class="ghost" disabled>Segment Divisions</button>
        <input id="divCount" type="number" min="1" max="50" value="10" style="width:70px;">

        <button id="btnResetView" class="ghost">Reset View</button>
      </div>
    </div>

    <div class="col panel stack">
      <div>
        <div><strong>Units (display only)</strong></div>
        <div class="controls">
          <button id="btnUS" class="ghost">US (in, lbs)</button>
          <button id="btnSI" class="ghost">SI (m, N)</button>
        </div>
        <div class="hint">Solver is unit-agnostic; keep inputs consistent.</div>
      </div>

      <div>
        <div><strong>Nodes</strong></div>
        <div id="nodeList" class="list"></div>
      </div>

      <div>
        <div><strong>Members</strong></div>
        <div id="memberList" class="list"></div>
      </div>

      <div>
        <div><strong>Results (primary nodes)</strong></div>
        <div id="resultList" class="list"></div>
      </div>

      <div id="stressPanelBlock">
        <div class="controls" style="justify-content:space-between;">
          <strong>Stress Panel</strong>
          <button id="btnCloseStressPanel" class="ghost">Close</button>
        </div>
        <canvas id="stressPanel"></canvas>
        <div id="stressPanelHint" class="hint" style="margin-top:6px;">
          Click a member (while this view is active) to plot σ<sub>L</sub> (red) & σ<sub>R</sub> (blue) vs length.
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Canvas & State =====
  const base = document.getElementById('base');
  const overlay = document.getElementById('overlay');
  const stressCanvas = document.getElementById('stressPanel');
  const stressBlock = document.getElementById('stressPanelBlock');
  const ctx = base.getContext('2d');
  const ovr = overlay.getContext('2d');
  const spx = stressCanvas.getContext('2d');

  const nodeList = document.getElementById('nodeList');
  const memberList = document.getElementById('memberList');
  const resultList = document.getElementById('resultList');

  const MAX_MEMBERS = 10;
  let mode = 'draw';       // 'draw' | 'select'
  let viewMode = 'geom';   // 'geom' | 'def' | 'stresspanel'
  let units = 'US';        // display only

  let nodes = [];          // {id,x,y, bc, Fx,Fy,M,Kx,Ky}
  let members = [];        // {id,n1,n2,E,A,I,S,c,wd,qix,qjx,qiy,qjy,release_i,release_j,label}
  let nextNodeId = 1, nextMemberId = 1;

  let dragStart = null, hoverEndNodeId = null;
  let lastSolution = null;
  let selectedMemberId = null;
  let selectedNodeId = null;
  let selectedMemberForDelete = null;
  let movingNodeId = null;
  let moveOffset = {dx:0, dy:0};

  // ===== Helpers =====
  const dist2 = (a,b,x,y) => (a-x)*(a-x)+(b-y)*(b-y);
  const nearNodeId = (x,y, tol=9) => {
    let best=null, dmin=tol*tol;
    for (const n of nodes) { const d=dist2(n.x,n.y,x,y); if (d<=dmin){best=n; dmin=d;} }
    return best?best.id:null;
  };
  const nodeById = id => nodes.find(n=>n.id===id);
  const memberById = id => members.find(m=>m.id===id);

  const pointToSegmentDistance = (p, a, b) => {
    const A={x:a.x,y:a.y}, B={x:b.x,y:b.y}, P=p;
    const ABx=B.x-A.x, ABy=B.y-A.y, APx=P.x-A.x, APy=P.y-A.y;
    const ab2 = ABx*ABx + ABy*ABy || 1e-9;
    let t = (APx*ABx + APy*ABy)/ab2; t=Math.max(0,Math.min(1,t));
    const Cx=A.x+t*ABx, Cy=A.y+t*ABy;
    return Math.hypot(P.x-Cx, P.y-Cy);
  };
  const nearMemberId = (x,y, tol=6) => {
    let bestId=null, best=tol;
    for (const m of members){
      const a=nodeById(m.n1), b=nodeById(m.n2);
      const d=pointToSegmentDistance({x,y},a,b);
      if (d<best){best=d; bestId=m.id;}
    }
    return bestId;
  };

  function addNode(x,y){
    const id=nextNodeId++;
    nodes.push({id,x,y,bc:'free',Fx:0,Fy:0,M:0,Kx:0,Ky:0});
    refreshLists();
    return id;
  }
  function addMember(n1,n2){
    if (members.length>=MAX_MEMBERS){ Swal.fire('Limit reached','Max 10 members for now.','info'); return null; }
    const id=nextMemberId++;
    let E=0,A=0,I=0,S=0,c=0,wd=0,qix=0,qjx=0,qiy=0,qjy=0,release_i=false,release_j=false,label=`M${id}`;
    if (members.length>=1){
      const t = members[0];
      ({E,A,I,S,c,wd,qix,qjx,qiy,qjy,release_i,release_j} = t);
    }
    members.push({ id,n1,n2,E,A,I,S,c,wd,qix,qjx,qiy,qjy,release_i,release_j,label });
    refreshLists();
    return id;
  }

  function deleteMember(id){
    const idx = members.findIndex(m=>m.id===id);
    if (idx<0) return;
    members.splice(idx,1);
    lastSolution = null;
    if (selectedMemberId===id) selectedMemberId=null;
    if (selectedMemberForDelete===id) selectedMemberForDelete=null;
    refreshLists(); draw();
  }

  function deleteNodeWithMembers(nodeId){
    const nidx = nodes.findIndex(n=>n.id===nodeId);
    if (nidx<0) return;
    members = members.filter(m => m.n1!==nodeId && m.n2!==nodeId);
    nodes.splice(nidx,1);
    lastSolution = null;
    if (selectedNodeId===nodeId) selectedNodeId=null;
    refreshLists(); draw();
  }

  // Canvas ↔ analysis Y
  const yUp = yCanvas => base.height - yCanvas;
  const yCanvas = yUpVal => base.height - yUpVal;

  // ===== Active button helpers =====
  const modeBtns = ['btnDraw','btnSelect'];
  const viewBtns = ['viewGeom','viewDef','viewStressPanel'];
  function setActiveGroup(ids, activeId){
    ids.forEach(id => document.getElementById(id).classList.toggle('active', id===activeId));
  }

  // ===== UI Buttons =====
  document.getElementById('btnDraw').onclick   = () => { mode='draw';   overlay.style.cursor='crosshair'; setActiveGroup(modeBtns,'btnDraw'); draw(); };
  document.getElementById('btnSelect').onclick = () => { mode='select'; overlay.style.cursor='pointer';   setActiveGroup(modeBtns,'btnSelect'); draw(); };

  document.getElementById('viewGeom').onclick = ()=>{ viewMode='geom'; toggleStressPanel(false); setActiveGroup(viewBtns,'viewGeom'); draw(); };
  document.getElementById('viewDef').onclick  = ()=>{ viewMode='def';  toggleStressPanel(false); setActiveGroup(viewBtns,'viewDef');  draw(); };
  document.getElementById('viewStressPanel').onclick = ()=>{ viewMode='stresspanel'; toggleStressPanel(true); setActiveGroup(viewBtns,'viewStressPanel'); draw(); };
  document.getElementById('btnCloseStressPanel').onclick = ()=>{ viewMode='geom'; toggleStressPanel(false); setActiveGroup(viewBtns,'viewGeom'); draw(); };

  document.getElementById('btnUndo').onclick = () => {
    lastSolution=null;
    if (dragStart){ dragStart=null; hoverEndNodeId=null; draw(); return; }
    if (members.length){ members.pop(); refreshLists(); draw(); return; }
    if (nodes.length){ nodes.pop(); refreshLists(); draw(); return; }
  };
  document.getElementById('btnClear').onclick = () => {
    nodes=[]; members=[]; nextNodeId=1; nextMemberId=1; lastSolution=null;
    selectedNodeId=null; selectedMemberForDelete=null; selectedMemberId=null;
    viewMode='geom'; toggleStressPanel(false);
    setActiveGroup(modeBtns,'btnDraw'); setActiveGroup(viewBtns,'viewGeom');
    refreshLists(); draw();
  };
  document.getElementById('btnExport').onclick = () => {
    const data={units,nodes,members};
    const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='framex.json'; a.click();
    URL.revokeObjectURL(url);
  };
  document.getElementById('btnUS').onclick = () => { units='US'; Swal.fire('Units set','US (in, lbs)','success'); };
  document.getElementById('btnSI').onclick = () => { units='SI'; Swal.fire('Units set','SI (m, N)','success'); };

  document.getElementById('btnSolve').onclick = () => solveFrame();
  document.getElementById('btnResetView').onclick = () => { lastSolution=null; draw(); };

  function toggleStressPanel(show){
    stressBlock.style.display = show ? 'block' : 'none';
    document.getElementById('stressPanelHint').style.display = show ? 'block' : 'none';
    if (show) resizeStressCanvas();
  }
  function resizeStressCanvas(){
    stressCanvas.style.width = '100%';
    const w = Math.max(200, stressCanvas.parentElement.clientWidth);
    const h = 260;
    stressCanvas.width = w;
    stressCanvas.height = h;
  }
  window.addEventListener('resize', ()=>{ if (stressBlock.style.display!=='none') resizeStressCanvas(); });

  // ===== Overlay Events =====
  overlay.addEventListener('mousedown', (e)=>{
    const {x,y}=mousePos(e);
    if (mode==='draw'){
      const nid=nearNodeId(x,y);
      let startNode, created=false, existing=false;
      if (nid){ startNode=nodeById(nid); existing=true; }
      else { const id=addNode(x,y); startNode=nodeById(id); created=true; }
      dragStart={x:startNode.x, y:startNode.y, nodeId:startNode.id, createdStart:created, existingStart:existing};
      hoverEndNodeId=null;
    } else if (mode==='select'){
      const nid = nearNodeId(x,y,8);
      if (nid){
        const n = nodeById(nid);
        movingNodeId = nid;
        moveOffset.dx = x - n.x;
        moveOffset.dy = y - n.y;
        selectedNodeId = nid;
        selectedMemberForDelete = null;
        overlay.style.cursor='grabbing';
      } else {
        movingNodeId = null;
      }
      dragStart={x,y,nodeId:null,createdStart:false}; hoverEndNodeId=null;
    }
    draw();
  });

  overlay.addEventListener('mousemove', (e)=>{
    const {x,y}=mousePos(e);
    if (mode==='draw' && dragStart){
      hoverEndNodeId = nearNodeId(x,y);
      draw();
      ovr.save();
      ovr.lineWidth=2; ovr.setLineDash([6,4]); ovr.strokeStyle='#3a86ff';
      ovr.beginPath(); ovr.moveTo(dragStart.x,dragStart.y); ovr.lineTo(x,y); ovr.stroke();
      if (dragStart.existingStart) highlightNode(ovr, nodeById(dragStart.nodeId));
      if (hoverEndNodeId) highlightNode(ovr, nodeById(hoverEndNodeId));
      ovr.restore();
    } else {
      draw();
      if (mode==='select'){
        if (movingNodeId!==null){
          const n = nodeById(movingNodeId);
          n.x = x - moveOffset.dx;
          n.y = y - moveOffset.dy;
          lastSolution = null;
          draw();
          return;
        }
        const mid=nearMemberId(x,y,6);
        const nid=nearNodeId(x,y,8);
        if (mid){
          const m=memberById(mid), a=nodeById(m.n1), b=nodeById(m.n2);
          ovr.save(); ovr.lineWidth=4; ovr.strokeStyle='#ff006e';
          ovr.beginPath(); ovr.moveTo(a.x,a.y); ovr.lineTo(b.x,b.y); ovr.stroke(); ovr.restore();
          overlay.style.cursor='pointer';
        } else if (nid){
          const n=nodeById(nid);
          ovr.save(); ovr.fillStyle='rgba(16,185,129,0.22)';
          ovr.beginPath(); ovr.arc(n.x,n.y,10,0,Math.PI*2); ovr.fill(); ovr.restore();
          overlay.style.cursor='pointer';
        } else {
          overlay.style.cursor='pointer';
        }
      }
    }
  });

  overlay.addEventListener('mouseup', (e)=>{
    const {x,y}=mousePos(e);
    if (mode==='draw' && dragStart){
      let nid=nearNodeId(x,y);
      let endNode;
      if (nid){ endNode=nodeById(nid); }
      else { const id=addNode(x,y); endNode=nodeById(id); }
      if (endNode.id===dragStart.nodeId){
        if (dragStart.createdStart){ nodes.pop(); }
        dragStart=null; hoverEndNodeId=null; draw(); return;
      }
      const mid=addMember(dragStart.nodeId, endNode.id);
      dragStart=null; hoverEndNodeId=null; draw();
      if (mid) editMember(memberById(mid));
      return;
    }
    if (mode==='select'){
      const mid=nearMemberId(x,y,6);
      const nid=nearNodeId(x,y,8);

      if (movingNodeId!==null){
        movingNodeId = null;
        overlay.style.cursor='pointer';
        draw();
        return;
      }

      if (viewMode==='stresspanel' && mid){
        selectedMemberId = mid;
        plotStressPanel();
        return;
      }

      if (nid){
        selectedNodeId = nid;
        selectedMemberForDelete = null;
        draw();
        return;
      }
      if (mid){
        selectedMemberForDelete = mid;
        selectedNodeId = null;
        draw();
        return;
      }

      selectedNodeId = null;
      selectedMemberForDelete = null;
      draw();
    }
  });

  overlay.addEventListener('dblclick', (e)=>{
    if (mode!=='select') return;
    const {x,y}=mousePos(e);
    const nid=nearNodeId(x,y,8);
    const mid=nearMemberId(x,y,6);
    if (nid){ editNode(nodeById(nid)); draw(); return; }
    if (mid){ editMember(memberById(mid)); draw(); return; }
  });

  document.addEventListener('keydown', (e)=>{
    if (mode!=='select') return;
    if (e.key==='Delete' || e.key==='Backspace'){
      if (selectedNodeId){
        deleteNodeWithMembers(selectedNodeId);
        selectedNodeId = null;
        e.preventDefault();
      } else if (selectedMemberForDelete){
        deleteMember(selectedMemberForDelete);
        selectedMemberForDelete = null;
        e.preventDefault();
      }
    }
  });

  function mousePos(e){ const r=overlay.getBoundingClientRect(); return { x:e.clientX-r.left, y:e.clientY-r.top }; }

  // ===== Editors =====
  function editNode(node){
    const bcOptions=[
      {value:'free',   text:'Free (no restraints)'},
      {value:'simple', text:'Simply supported: u=0, v=0, θ free'},
      {value:'fixed',  text:'Fixed: u=0, v=0, θ=0'},
    ];
    const html = `
      <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;">
        <label style="grid-column:1/3; font-weight:600;">Boundary Condition</label>
        <select id="bc" class="swal2-select" style="grid-column:1/3;">
          ${bcOptions.map(o=>`<option value="${o.value}" ${node.bc===o.value?'selected':''}>${o.text}</option>`).join('')}
        </select>
        <div style="grid-column:1/3; display:flex; gap:10px; align-items:center;">
          <canvas id="bcGlyph" width="180" height="60" style="border:1px dashed #ddd; border-radius:6px;"></canvas>
          <span class="hint">Global axes</span>
        </div>
        <label style="grid-column:1/3; font-weight:600; margin-top:6px;">Nodal Loads</label>
        <label>Fx</label><input id="Fx" class="swal2-input" type="number" step="any" value="${node.Fx}">
        <label>Fy</label><input id="Fy" class="swal2-input" type="number" step="any" value="${node.Fy}">
        <label>Moment</label><input id="M" class="swal2-input" type="number" step="any" value="${node.M}">
        <label style="grid-column:1/3; font-weight:600; margin-top:6px;">Translational Springs</label>
        <label>Kx</label><input id="Kx" class="swal2-input" type="number" step="any" value="${node.Kx}">
        <label>Ky</label><input id="Ky" class="swal2-input" type="number" step="any" value="${node.Ky}">
      </div>`;
    Swal.fire({
      title:`Node ${node.id}`,
      html, showCancelButton:true, confirmButtonText:'Save',
      didOpen:()=>{
        const g=document.getElementById('bcGlyph').getContext('2d');
        const sel=document.getElementById('bc');
        drawBCGlyph(g, sel.value);
        sel.addEventListener('change', ev => drawBCGlyph(g, ev.target.value));
      },
      preConfirm:()=>{
        const v = id => parseFloat(document.getElementById(id).value)||0;
        return { bc:document.getElementById('bc').value, Fx:v('Fx'), Fy:v('Fy'), M:v('M'), Kx:v('Kx'), Ky:v('Ky') };
      }
    }).then(res=>{ if (res.isConfirmed){ Object.assign(node,res.value); refreshLists(); draw(); }});
  }

  function editMember(m){
    const html = `
      <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px; align-items:center;">
        <label>Label</label><input id="label" class="swal2-input" type="text" value="${m.label||''}">
        <div style="grid-column:1/3; height:1px; background:#ececec; margin:6px 0;"></div>

        <label>E</label><input id="E" class="swal2-input" type="number" step="any" value="${m.E}">
        <label>wd (weight density)</label><input id="wd" class="swal2-input" type="number" step="any" value="${m.wd}">
        <label>A</label><input id="A" class="swal2-input" type="number" step="any" value="${m.A}">
        <label>I</label><input id="I" class="swal2-input" type="number" step="any" value="${m.I}">
        <label>S (optional)</label><input id="S" class="swal2-input" type="number" step="any" value="${m.S||0}">
        <div class="hint" style="grid-column:1/3;">If S is given, c = I / S will be inferred for stresses.</div>

        <div style="grid-column:1/3; height:1px; background:#ececec; margin:6px 0;"></div>

        <label>qix</label><input id="qix" class="swal2-input" type="number" step="any" value="${m.qix}">
        <label>qjx</label><input id="qjx" class="swal2-input" type="number" step="any" value="${m.qjx}">
        <label>qiy</label><input id="qiy" class="swal2-input" type="number" step="any" value="${m.qiy}">
        <label>qjy</label><input id="qjy" class="swal2-input" type="number" step="any" value="${m.qjy}">
        <label style="grid-column:1/3; font-weight:600; margin-top:6px;">End Releases (internal hinges)</label>
        <label><input id="relI" type="checkbox" ${m.release_i?'checked':''}/> Release iθ</label>
        <label><input id="relJ" type="checkbox" ${m.release_j?'checked':''}/> Release jθ</label>
      </div>`;
    Swal.fire({
      title:`Member ${m.id}`,
      html, showCancelButton:true, confirmButtonText:'Save',
      preConfirm:()=>{
        const v=id=>parseFloat(document.getElementById(id)?.value)||0;
        const s=id=>document.getElementById(id)?.value||'';
        let A=v('A'), I=v('I'), S=v('S');
        let c = (S>0 && I>0) ? (I/S) : (m.c||0);
        if ((S<=0) && (I>0 && c>0)) S = I/c;
        return {
          label: s('label').trim(),
          E:v('E'), wd:v('wd'),
          A: A||0, I: I||0, c: c||0, S: S||0,
          qix:v('qix'), qjx:v('qjx'), qiy:v('qiy'), qjy:v('qjy'),
          release_i: document.getElementById('relI').checked,
          release_j: document.getElementById('relJ').checked
        };
      }
    }).then(res=>{ if (res.isConfirmed){ Object.assign(m,res.value); refreshLists(); draw(); }});
  }

  // ===== BC glyph preview =====
  function drawBCGlyph(g, bc){
    g.clearRect(0,0,g.canvas.width,g.canvas.height);
    g.save();
    g.translate(20, g.canvas.height-20);
    g.strokeStyle='#aaa'; g.lineWidth=1;
    g.beginPath(); g.moveTo(0,0); g.lineTo(140,0); g.stroke();
    g.beginPath(); g.moveTo(0,0); g.lineTo(0,-40); g.stroke();
    if (bc==='fixed'){
      g.lineWidth=6; g.strokeStyle='#222';
      g.beginPath(); g.moveTo(0,0); g.lineTo(0,-30); g.stroke();
    } else if (bc==='simple'){
      g.fillStyle='#222';
      g.beginPath(); g.moveTo(0,0); g.lineTo(-12,12); g.lineTo(12,12); g.closePath(); g.fill();
      g.fillRect(-16,12,32,3);
    }
    g.restore();
  }

  // ===== Draw =====
  function draw(){
    ctx.clearRect(0,0,base.width,base.height);
    ovr.clearRect(0,0,overlay.width,overlay.height);
    drawGrid(ctx);

    const qScale = computeQScale();

    // Members & loads
    ctx.save();
    ctx.lineWidth=2; ctx.strokeStyle='#222';
    ctx.font='12px system-ui'; ctx.fillStyle='#000';

    for (const m of members){
      const a=nodeById(m.n1), b=nodeById(m.n2);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();

      drawEndReleaseGlyphs(ctx, m);
      const mx=(a.x+b.x)/2, my=(a.y+b.y)/2;
      ctx.fillText(m.label||`M${m.id}`, mx+4, my-6);

      if (viewMode==='geom' || viewMode==='def'){
        drawDistributedLoads(ctx, m, qScale);
      }
    }
    ctx.restore();

    for (const n of nodes){
      drawNodeBC(ctx, n);
      drawNodeLoadsAndSprings(ctx, n);
      ctx.save(); ctx.fillStyle='#1d4ed8';
      ctx.beginPath(); ctx.arc(n.x,n.y,4,0,Math.PI*2); ctx.fill(); ctx.restore();
    }

    if (viewMode==='def' && lastSolution){
      const scale = parseFloat(document.getElementById('defScale').value)||1;
      ctx.save();
      ctx.lineWidth=2; ctx.strokeStyle='#e11d48';
      for (const poly of lastSolution.sublines){
        ctx.beginPath();
        for (let k=0;k<poly.length;k++){
          const p=poly[k];
          const xc = p.x_up - scale*p.u;
          const yc = yCanvas(p.y_up + scale*p.v);
          if (k===0) ctx.moveTo(xc, yc); else ctx.lineTo(xc, yc);
        }
        ctx.stroke();
      }
      ctx.restore();
    }

    drawSelection();
  }

  function drawSelection(){
    if (selectedNodeId){
      const n = nodeById(selectedNodeId);
      if (n){
        ovr.save();
        ovr.lineWidth=3; ovr.strokeStyle='#10b981';
        ovr.beginPath(); ovr.arc(n.x,n.y,12,0,Math.PI*2); ovr.stroke();
        ovr.restore();
      }
    }
    if (selectedMemberForDelete){
      const m = memberById(selectedMemberForDelete);
      if (m){
        const a=nodeById(m.n1), b=nodeById(m.n2);
        ovr.save(); ovr.lineWidth=4; ovr.strokeStyle='#f59e0b';
        ovr.beginPath(); ovr.moveTo(a.x,a.y); ovr.lineTo(b.x,b.y); ovr.stroke();
        ovr.restore();
      }
    }
  }

  function drawGrid(g){
    const step=40;
    g.save();
    g.lineWidth=1; g.strokeStyle='#eee'; g.fillStyle='#999';
    for (let x=0; x<=base.width; x+=step){ g.beginPath(); g.moveTo(x,0); g.lineTo(x,base.height); g.stroke(); if (x%160===0) g.fillText(x, x+2, 12); }
    for (let y=0; y<=base.height; y+=step){ g.beginPath(); g.moveTo(0,y); g.lineTo(base.width,y); g.stroke(); if (y%160===0) g.fillText(y, 2, y-2); }
    g.restore();
  }

  function drawNodeBC(g, node){
    const {x,y,bc}=node;
    g.save(); g.strokeStyle='#000'; g.fillStyle='#000';
    if (bc==='fixed'){
      g.lineWidth=6; g.beginPath(); g.moveTo(x-10, y-16); g.lineTo(x-10, y+16); g.stroke();
      g.lineWidth=1; g.strokeStyle='#666';
      for (let k=-14; k<=14; k+=7){ g.beginPath(); g.moveTo(x-10, y+k); g.lineTo(x-18, y+k-6); g.stroke(); }
    } else if (bc==='simple'){
      g.beginPath(); g.moveTo(x, y+8); g.lineTo(x-10, y+18); g.lineTo(x+10, y+18); g.closePath(); g.fill();
      g.fillRect(x-14, y+18, 28, 3);
    }
    g.restore();
  }

  function drawNodeLoadsAndSprings(g, node){
    if (viewMode==='stresspanel') return;
    const {x,y,Fx,Fy,M,Kx,Ky}=node;
    g.save();
    g.strokeStyle='#db2777'; g.fillStyle='#db2777'; g.lineWidth=2;
    if (Fx!==0){ const sign=Fx>0?1:-1, L=26*sign; drawArrow(g,x,y,x+L,y); g.fillText('Fx', x+L+(sign>0?6:-18), y-6); }
    if (Fy!==0){ const sign=Fy>0?-1:1, L=26*sign; drawArrow(g,x,y,x,y+L); g.fillText('Fy', x+6, y+L+(sign<0?-8:14)); }
    if (M!==0){ const ccw=M>0; drawCurvedArrow(g,x,y,ccw); g.fillText('M', x+12, y-12); }
    g.strokeStyle='#0f766e'; g.fillStyle='#0f766e'; g.lineWidth=2;
    if (Kx>0){ drawSpringX(g, x+16, y, 18, 6); g.fillText('Kx', x+40, y-6); }
    if (Ky>0){ drawSpringY(g, x, y+16, 18, 6); g.fillText('Ky', x+6, y+42); }
    g.restore();
  }

  // ===== q-load graphics =====
  function computeQScale(){
    let maxQx=0, maxQy=0;
    for (const m of members){
      maxQx = Math.max(maxQx, Math.abs(m.qix), Math.abs(m.qjx));
      maxQy = Math.max(maxQy, Math.abs(m.qiy), Math.abs(m.qjy));
    }
    return { maxQx: maxQx || 1, maxQy: maxQy || 1, lenX:28, lenY:28 };
  }

  function drawDistributedLoads(g, m, qScale){
    const a=nodeById(m.n1), b=nodeById(m.n2);
    const dx=b.x-a.x, dy=b.y-a.y;
    const markers = 12;

    // qx
    for (let k=0;k<=markers;k++){
      const t=k/markers, x=a.x+dx*t, y=a.y+dy*t;
      const qx = m.qix + (m.qjx - m.qix)*t;
      if (Math.abs(qx)>1e-12){
        const dir = Math.sign(qx)||1, len=Math.max(8, Math.abs(qx)/qScale.maxQx*qScale.lenX);
        drawArrow(g, x, y, x + dir*len, y);
        if (k===Math.floor(markers/2)) g.fillText('qx', x + dir*len + (dir>0?6:-18), y-6);
      }
    }
    // qy
    for (let k=0;k<=markers;k++){
      const t=k/markers, x=a.x+dx*t, y=a.y+dy*t;
      const qy = m.qiy + (m.qjy - m.qiy)*t;
      if (Math.abs(qy)>1e-12){
        const up=qy>0, len=Math.max(8, Math.abs(qy)/qScale.maxQy*qScale.lenY);
        drawArrow(g, x, y, x, y + (up ? -len : +len));
        if (k===Math.floor(markers/2)) g.fillText('qy', x+6, y + (up ? -len-6 : len+14));
      }
    }
  }

  function drawEndReleaseGlyphs(g, m){
    const a=nodeById(m.n1), b=nodeById(m.n2);
    if (!a || !b) return;
    const dx=b.x-a.x, dy=b.y-a.y;
    const L=Math.hypot(dx,dy)||1e-9, ux=dx/L, uy=dy/L;
    g.save(); g.lineWidth=2; g.strokeStyle='#111';
    const r=5, off=8;
    if (m.release_i){ g.beginPath(); g.arc(a.x+ux*off, a.y+uy*off, r,0,Math.PI*2); g.stroke(); }
    if (m.release_j){ g.beginPath(); g.arc(b.x-ux*off, b.y-uy*off, r,0,Math.PI*2); g.stroke(); }
    g.restore();
  }

  // ===== Solver + stresses =====
  function solveFrame(){
    const DIV = Math.max(1, Math.min(50, (parseInt(document.getElementById('divCount').value)||10)));
    try {
      const build = buildAnalysisModel(DIV);
      const {N, dofMap, anodes, F, K, memberSubs} = build;

      // Springs
      for (const n of nodes){
        const base = dofMap.primary[n.id]; if (base===undefined) continue;
        if (n.Kx>0) K[base+0][base+0] += n.Kx;
        if (n.Ky>0) K[base+1][base+1] += n.Ky;
      }
      // Nodal loads
      for (const n of nodes){
        const b = dofMap.primary[n.id]; if (b===undefined) continue;
        F[b+0] += n.Fx; F[b+1] += n.Fy; F[b+2] += n.M;
      }

      // BCs
      const constrained = new Set();
      for (const n of nodes){
        const b = dofMap.primary[n.id]; if (b===undefined) continue;
        if (n.bc==='fixed'){ constrained.add(b+0); constrained.add(b+1); constrained.add(b+2); }
        else if (n.bc==='simple'){ constrained.add(b+0); constrained.add(b+1); } // u=v=0
      }

      const allIdx = [...Array(N).keys()];
      const freeIdx = allIdx.filter(i => !constrained.has(i));
      if (freeIdx.length===0){ Swal.fire('No free DOFs','All DOFs are constrained.','error'); return; }

      const Kff = matPick(K, freeIdx, freeIdx);
      const Ff  = vecPick(F, freeIdx);
      let Uf;
      try { Uf = numeric.solve(Kff, Ff); } catch { throw new Error('singular'); }
      if (Uf.some(v => !isFinite(v))) throw new Error('singular');

      const U = Array(N).fill(0);
      freeIdx.forEach((gi, k) => { U[gi] = Uf[k]; });

      // Reactions (optional)
      const KU = numeric.dot(K, U);
      const R = KU.map((v,i)=>v - F[i]);

      // Deformed sublines (for viewDef)
      const sublines = [];
      for (const mem of members){
        const poly = [];
        const sub = memberSubs[mem.id];
        for (const nid of sub){
          const aidx = build.dofMap.analysis[nid];
          const ux = U[aidx+0], vy = U[aidx+1];
          const np = build.anodes[nid];
          poly.push({ x_up: np.x_up, y_up: np.y_up, u: ux, v: vy });
        }
        sublines.push(poly);
      }

      // Internal forces -> stresses
      const mf = elementEndForces(U, build); // per member M,N at subnodes
      const stress = {};
      for (const mem of members){
        const info = mf.perMember[mem.id]; if (!info) continue;
        const A=mem.A||0, S = (mem.S>0)? mem.S : ((mem.I>0 && mem.c>0)? mem.I/mem.c : 0);
        const sL=[], sR=[], pts=[];
        const sub = memberSubs[mem.id];
        for (let idx=0; idx<sub.length; idx++){
          const aid = sub[idx];
          const np = build.anodes[aid];
          const N = info.N[idx]||0;
          const M = info.M[idx]||0;             // will be 0 for axial-only spans
          let sigL=0, sigR=0;
          if (A>0){
            const axial = N/A;
            if (S>0){
              sigL = axial - M/S;  // left (+local y)
              sigR = axial + M/S;  // right (−local y)
            } else {
              sigL = sigR = axial; // fallback / axial-only
            }
          }
          sL.push(sigL); sR.push(sigR);
          pts.push({x_up:np.x_up, y_up:np.y_up});
        }
        stress[mem.id] = { pts, sL, sR };
      }

      lastSolution = { Ufull:U, dofMap:build.dofMap, anodes:build.anodes, sublines, reactions:R, stress, memberSubs };

      // primary node displacements
      lastSolution.primaryRes = nodes.map(n=>{
        const b = build.dofMap.primary[n.id];
        return { id:n.id, ux:round6(U[b+0]), uy:round6(U[b+1]), th:round6(U[b+2]) };
      });
      showResults(lastSolution.primaryRes);

      // Auto deflection scale (~20% of model size)
      const bbox = modelBounds(); // in canvas px
      const Lref = Math.max(bbox.w, bbox.h) || 1;

      let maxDisp=0;
      for (const aidStr of Object.keys(lastSolution.anodes)){
        const aid = parseInt(aidStr,10);
        const b = lastSolution.dofMap.analysis[aid];
        const u = lastSolution.Ufull[b+0], v = lastSolution.Ufull[b+1];
        maxDisp = Math.max(maxDisp, Math.hypot(u,v));
      }
      const defScaleAuto = (maxDisp>0) ? (0.20*Lref/maxDisp) : 1;
      document.getElementById('defScale').value = +defScaleAuto.toFixed(4);

      if (viewMode==='stresspanel') plotStressPanel();
      draw();
    } catch (err){
      console.error(err);
      Swal.fire({
        icon:'error',
        title:'Solve failed',
        html:`<div style="text-align:left">
          <div><b>Likely causes</b></div>
          <ul style="margin:6px 0 0 18px;">
            <li>Under-constrained model (needs enough supports/fixity).</li>
            <li>Member has zero length or missing E/A/I (and S for stresses if custom).</li>
          </ul>
        </div>`
      });
    }
  }

  // ===== Build FEM model =====
  function buildAnalysisModel(DIV){
    const anodes = {};
    const dofMap = { primary:{}, analysis:{} };
    let aNextId = 1;

    for (const n of nodes){
      const id=aNextId++;
      anodes[id] = { x_up:n.x, y_up:yUp(n.y), primary:n.id };
      dofMap.primary[n.id] = (id-1)*3;
      dofMap.analysis[id] = (id-1)*3;
    }

    const memberSubs = {};
    const elems = [];
    for (const m of members){
      const ni = getAnalysisIdForPrimary(m.n1, anodes);
      const nj = getAnalysisIdForPrimary(m.n2, anodes);
      const pi = anodes[ni], pj = anodes[nj];
      const dx = pj.x_up - pi.x_up, dy = pj.y_up - pi.y_up;
      const L = Math.hypot(dx,dy); if (L<1e-9) continue;

      const subNodes=[ni];
      for (let k=1; k<=DIV; k++){
        const t=k/(DIV+1);
        const id=aNextId++;
        anodes[id]={ x_up: pi.x_up + t*dx, y_up: pi.y_up + t*dy };
        dofMap.analysis[id]=(id-1)*3;
        subNodes.push(id);
      }
      subNodes.push(nj);
      memberSubs[m.id]=subNodes;

      for (let s=0; s<subNodes.length-1; s++){
        const a=subNodes[s], b=subNodes[s+1];
        const aP=anodes[a], bP=anodes[b];
        const segLen = Math.hypot(bP.x_up-aP.x_up, bP.y_up-aP.y_up);
        const c = (bP.x_up-aP.x_up)/segLen, sgn = (bP.y_up-aP.y_up)/segLen;

        // average loads for this sub-element (global)
        const DIVs=subNodes.length-1;
        const t0 = s/(DIVs), t1 = (s+1)/(DIVs);
        const qx0 = lerp(m.qix, m.qjx, t0), qx1 = lerp(m.qix, m.qjx, t1);
        const qy0 = lerp(m.qiy, m.qjy, t0), qy1 = lerp(m.qiy, m.qjy, t1);
        const sw  = (m.wd||0)*(m.A||0); // self-weight per length
        const qx_avg = 0.5*(qx0+qx1);
        const qy_avg = 0.5*(qy0+qy1) - sw;

        // local uniform p,w
        const p =  c*qx_avg + sgn*qy_avg;     // axial per length (local x)
        const w = -sgn*qx_avg + c*qy_avg;     // transverse per length (local y, +left)

        // ★ Decide element behavior
        const eps = 1e-12;
        const axialOnly = (m.release_i && m.release_j && Math.abs(w) < eps);

        elems.push({
          i:a, j:b, L:segLen, c, s:sgn, E:m.E||0, A:m.A||0, I:m.I||0,
          memId:m.id, p, w,
          rel_i:(s===0)&&!!m.release_i, rel_j:(s===subNodes.length-2)&&!!m.release_j,
          mode: axialOnly ? 'axial' : 'beam'  // ★
        });
      }
    }

    const N = Object.keys(anodes).length * 3;
    const K = zeros(N,N);
    const F = zeros(N);

    // Assembly
    for (const el of elems){
      // ★ Choose stiffness & fixed-end vector by mode
      let kLocal, fLoc;
      if (el.mode === 'axial'){
        kLocal = frameKLocalAxial(el.E, el.A, el.L);
        fLoc   = [ el.p*el.L/2, 0,0,  el.p*el.L/2, 0,0 ];
      } else {
        kLocal = frameKLocal(el.E, el.A, el.I, el.L);
        fLoc   = [
          el.p*el.L/2, el.w*el.L/2,  el.w*el.L*el.L/12,
          el.p*el.L/2, el.w*el.L/2, -el.w*el.L*el.L/12
        ];
      }

      const T = frameT(el.c, el.s);
      let kG = numeric.dot(numeric.transpose(T), numeric.dot(kLocal, T));
      let fG = numeric.dot(numeric.transpose(T), fLoc);

      // End releases (only meaningful for BEAM mode)
      const relIdx=[];
      if (el.mode !== 'axial'){
        if (el.rel_i) relIdx.push(2);
        if (el.rel_j) relIdx.push(5);
      }

      if (relIdx.length){
        const {Keff, feff} = condenseDOFs(kG, fG, relIdx);
        kG=Keff; fG=feff;
      }

      const ib = dofMap.analysis[el.i], jb = dofMap.analysis[el.j];
      const fullMap=[ib+0, ib+1, ib+2, jb+0, jb+1, jb+2];
      const kept = (relIdx.length)? keptMapFromRemoved(fullMap, relIdx) : fullMap;

      addToGlobalVar(K, kG, kept);
      addToGlobalVecVar(F, fG, kept);
    }

    return { N, dofMap, anodes, F, K, memberSubs, elems };
  }

  // ===== Internal forces → M,N along each member (local)
  function elementEndForces(U, build){
    const perElem=[];
    const perMember={};
    for (const el of build.elems){
      let kLocal, fFixed;

      if (el.mode === 'axial'){ // ★ axial-only
        kLocal = frameKLocalAxial(el.E, el.A, el.L);
        fFixed = [ el.p*el.L/2, 0,0,  el.p*el.L/2, 0,0 ];
      } else {                  // beam
        kLocal = frameKLocal(el.E, el.A, el.I, el.L);
        fFixed = [ el.p*el.L/2, el.w*el.L/2,  el.w*el.L*el.L/12,
                   el.p*el.L/2, el.w*el.L/2, -el.w*el.L*el.L/12 ];
      }

      const T = frameT(el.c, el.s);

      const ib = build.dofMap.analysis[el.i], jb=build.dofMap.analysis[el.j];
      const dGlob=[ U[ib+0],U[ib+1],U[ib+2], U[jb+0],U[jb+1],U[jb+2] ];
      const dLoc = numeric.dot(T, dGlob);

      let fLoc = numeric.sub(numeric.dot(kLocal, dLoc), fFixed);

      // zero end moments at released ends (only for beam)
      if (el.mode !== 'axial'){
        if (el.rel_i) fLoc[2]=0;
        if (el.rel_j) fLoc[5]=0;
      } else {
        // ensure no spurious moment
        fLoc[2]=0; fLoc[5]=0;
      }

      perElem.push({el, fLoc});

      const memId = el.memId;
      const sub = build.memberSubs[memId];
      if (!perMember[memId]){
        perMember[memId] = { nodes: sub.slice(), M: new Array(sub.length).fill(0), N: new Array(sub.length).fill(0), cnt:new Array(sub.length).fill(0) };
      }
      const info = perMember[memId];

      const idx_i = sub.indexOf(el.i);
      const idx_j = sub.indexOf(el.j);
      const Ni = fLoc[0], Mi = (el.mode==='axial') ? 0 : fLoc[2];
      const Nj = -fLoc[3], Mj = (el.mode==='axial') ? 0 : -fLoc[5];

      info.M[idx_i] += Mi; info.cnt[idx_i] += 1;
      info.M[idx_j] += Mj; info.cnt[idx_j] += 1;

      info.N[idx_i] += Ni; info.N[idx_j] += Nj;
    }
    for (const memId of Object.keys(perMember)){
      const info=perMember[memId];
      for (let k=0;k<info.nodes.length;k++){
        if (info.cnt[k]>0){ info.M[k] /= info.cnt[k]; }
      }
    }
    return { perElem, perMember };
  }

  // ===== Stress Panel =====
  function plotStressPanel(){
    if (stressBlock.style.display==='none') return;
    resizeStressCanvas();
    const w=stressCanvas.width, h=stressCanvas.height;
    spx.clearRect(0,0,w,h);
    if (!lastSolution || !selectedMemberId){
      spx.save(); spx.fillStyle='#999'; spx.fillText('Solve and click a member to plot stresses.', 10, 20); spx.restore(); return;
    }
    const st = lastSolution.stress[selectedMemberId];
    if (!st){ spx.fillText('Selected member has no stress data.', 10, 20); return; }

    // Build x (0..L) along member
    const xs=[0]; let Lsum=0;
    for (let i=1;i<st.pts.length;i++){
      const x0=st.pts[i-1].x_up, y0=st.pts[i-1].y_up, x1=st.pts[i].x_up, y1=st.pts[i].y_up;
      Lsum += Math.hypot(x1-x0, y1-y0);
      xs.push(Lsum);
    }

    // Flip sign for plotting (UI convention)
    const SLp = st.sL.map(v => -v);
    const SRp = st.sR.map(v => -v);

    const minS = Math.min(...SLp, ...SRp), maxS=Math.max(...SLp,...SRp);
    const left=45, right=15, top=15, bot=30;

    spx.save();
    spx.strokeStyle='#444'; spx.lineWidth=1;
    spx.beginPath(); spx.moveTo(left, top); spx.lineTo(left, h-bot); spx.lineTo(w-right, h-bot); spx.stroke();
    spx.fillStyle='#333'; spx.fillText('σ', 8, top+10); spx.fillText('x', w-right-10, h-bot+18);

    const xMap = x => left + (w-left-right)*(x/Lsum || 0);
    const yMap = s => (h-bot) - (h-top-bot) * ((s - minS) / (maxS - minS || 1));

    // zero line
    const y0 = yMap(0); spx.strokeStyle='#ddd'; spx.setLineDash([4,4]);
    spx.beginPath(); spx.moveTo(left, y0); spx.lineTo(w-right, y0); spx.stroke(); spx.setLineDash([]);

    // SL curve (red)
    spx.strokeStyle='#ef4444'; spx.beginPath();
    for (let i=0;i<xs.length;i++){ const x=xMap(xs[i]), y=yMap(SLp[i]); if (i===0) spx.moveTo(x,y); else spx.lineTo(x,y); } spx.stroke();
    // SR curve (blue)
    spx.strokeStyle='#3b82f6'; spx.beginPath();
    for (let i=0;i<xs.length;i++){ const x=xMap(xs[i]), y=yMap(SRp[i]); if (i===0) spx.moveTo(x,y); else spx.lineTo(x,y); } spx.stroke();

    spx.fillStyle='#666';
    spx.fillText(`${minS.toFixed(3)}`, 6, yMap(minS)+4);
    spx.fillText(`${maxS.toFixed(3)}`, 6, yMap(maxS)+4);
    spx.fillText(`Member ${selectedMemberId}`, left+6, top+12);
    spx.restore();
  }

  // ===== Math & assembly helpers =====
  function frameKLocal(E,A,I,L){
    const EA=(E||0)*(A||0), EI=(E||0)*(I||0);
    const L2=L*L, L3=L2*L;
    return [
      [ EA/L,      0,           0,    -EA/L,      0,           0 ],
      [ 0,     12*EI/L3,   6*EI/L2,     0,   -12*EI/L3,   6*EI/L2 ],
      [ 0,      6*EI/L2,    4*EI/L,     0,    -6*EI/L2,    2*EI/L ],
      [ -EA/L,     0,           0,     EA/L,      0,           0 ],
      [ 0,    -12*EI/L3,  -6*EI/L2,     0,    12*EI/L3,  -6*EI/L2 ],
      [ 0,      6*EI/L2,    2*EI/L,     0,    -6*EI/L2,    4*EI/L ]
    ];
  }

  // ★ Axial-only local stiffness (EA only; rows/cols for v,θ are zeros)
  function frameKLocalAxial(E, A, L){
    const EA = (E||0)*(A||0);
    return [
      [ EA/L, 0,0, -EA/L, 0,0 ],
      [ 0,    0,0,  0,    0,0 ],
      [ 0,    0,0,  0,    0,0 ],
      [ -EA/L,0,0,  EA/L, 0,0 ],
      [ 0,    0,0,  0,    0,0 ],
      [ 0,    0,0,  0,    0,0 ],
    ];
  }

  function frameT(c,s){
    return [
      [ c, -s, 0,  0,  0, 0 ],
      [ s,  c, 0,  0,  0, 0 ],
      [ 0,  0, 1,  0,  0, 0 ],
      [ 0,  0, 0,  c, -s, 0 ],
      [ 0,  0, 0,  s,  c, 0 ],
      [ 0,  0, 0,  0,  0, 1 ],
    ];
  }

  function condenseDOFs(K, f, removeIdxs){
    let A = K.map(row=>row.slice());
    let b = f.slice();
    const rel = removeIdxs.slice().sort((a,b)=>b-a);
    let keptIdx = [0,1,2,3,4,5];
    for (const r of rel){
      const Krr = Math.abs(A[r][r])<1e-12 ? (A[r][r]>=0?1e-12:-1e-12) : A[r][r];
      for (let i=0;i<A.length;i++){
        if (i===r) continue;
        const Kir = A[i][r];
        if (Math.abs(Kir)<1e-18) continue;
        for (let j=0;j<A.length;j++){
          if (j===r) continue;
          A[i][j] = A[i][j] - Kir * A[r][j] / Krr;
        }
        b[i] = b[i] - Kir * b[r] / Krr;
      }
      for (let i=0;i<A.length;i++){ A[i].splice(r,1); }
      A.splice(r,1);
      b.splice(r,1);
      keptIdx.splice(keptIdx.indexOf(r),1);
      keptIdx = keptIdx.map(x => x>r ? x-1 : x);
    }
    return {Keff:A, feff:b, keptIdx};
  }
  function keptMapFromRemoved(fullMap, removeIdxs){
    const keep = [0,1,2,3,4,5].filter(i=>!removeIdxs.includes(i));
    return keep.map(i=>fullMap[i]);
  }

  function addToGlobalVar(K, ke, map){
    for (let r=0;r<map.length;r++){
      const R=map[r];
      for (let c=0;c<map.length;c++){
        const C=map[c];
        K[R][C] += ke[r][c];
      }
    }
  }
  function addToGlobalVecVar(F, fe, map){
    for (let r=0;r<map.length;r++){ F[map[r]] += fe[r]; }
  }
  function matPick(A, rows, cols){ const M=rows.length,N=cols.length,out=new Array(M); for(let i=0;i<M;i++){ out[i]=new Array(N); for(let j=0;j<N;j++) out[i][j]=A[rows[i]][cols[j]]; } return out; }
  function vecPick(v, rows){ return rows.map(i=>v[i]); }
  function getAnalysisIdForPrimary(pid, anodes){ for (const [aid,obj] of Object.entries(anodes)){ if (obj.primary===pid) return parseInt(aid); } return null; }
  function zeros(n,m){ if (m===undefined){ const v=new Array(n); for (let i=0;i<n;i++) v[i]=0; return v; } const A=new Array(n); for (let i=0;i<n;i++){ A[i]=new Array(m); for (let j=0;j<m;j++) A[i][j]=0; } return A; }
  const round6 = x => Math.abs(x)<1e-12 ? 0 : Math.round(x*1e6)/1e6;
  const lerp = (a,b,t)=> a + (b-a)*t;

  function modelBounds(){
    if (nodes.length===0) return {x0:0,y0:0,w:1,h:1};
    let minx=+Infinity, miny=+Infinity, maxx=-Infinity, maxy=-Infinity;
    for (const n of nodes){ minx=Math.min(minx,n.x); maxx=Math.max(maxx,n.x); miny=Math.min(miny,n.y); maxy=Math.max(maxy,n.y); }
    return {x0:minx, y0:miny, w:(maxx-minx)||1, h:(maxy-miny)||1};
  }

  // Small drawing helpers
  function drawArrow(g, x1,y1, x2,y2){
    g.beginPath(); g.moveTo(x1,y1); g.lineTo(x2,y2); g.stroke();
    const ang=Math.atan2(y2-y1, x2-x1), ah=7;
    g.beginPath();
    g.moveTo(x2,y2);
    g.lineTo(x2 - ah*Math.cos(ang - Math.PI/6), y2 - ah*Math.sin(ang - Math.PI/6));
    g.lineTo(x2 - ah*Math.cos(ang + Math.PI/6), y2 - ah*Math.sin(ang + Math.PI/6));
    g.closePath(); g.fill();
  }
  function drawCurvedArrow(g, x,y, ccw=true){
    g.beginPath(); g.arc(x, y, 14, ccw?Math.PI*0.1:Math.PI*1.1, ccw?Math.PI*1.6:Math.PI*0.6, !ccw); g.stroke();
    const ang=ccw?Math.PI*1.6:Math.PI*0.6, xe=x+14*Math.cos(ang), ye=y+14*Math.sin(ang), ah=7;
    g.beginPath(); g.moveTo(xe,ye);
    g.lineTo(xe - ah*Math.cos(ang - Math.PI/6), ye - ah*Math.sin(ang - Math.PI/6));
    g.lineTo(xe - ah*Math.cos(ang + Math.PI/6), ye - ah*Math.sin(ang + Math.PI/6));
    g.closePath(); g.fill();
  }
  function drawSpringX(g, x,y, len=20, amp=5){
    const n=5, dx=len/(n*2);
    g.beginPath(); g.moveTo(x,y);
    for (let i=0;i<n;i++){ g.lineTo(x+dx*(2*i+1), y-amp); g.lineTo(x+dx*(2*i+2), y+amp); }
    g.stroke();
  }
  function drawSpringY(g, x,y, len=20, amp=5){
    const n=5, dy=len/(n*2);
    g.beginPath(); g.moveTo(x,y);
    for (let i=0;i<n;i++){ g.lineTo(x-amp, y+dy*(2*i+1)); g.lineTo(x+amp, y+dy*(2*i+2)); }
    g.stroke();
  }
  function highlightNode(g, n){
    if (!n) return;
    g.save();
    g.lineWidth=3; g.strokeStyle='#10b981';
    g.beginPath(); g.arc(n.x,n.y,10,0,Math.PI*2); g.stroke();
    g.restore();
  }

  // ===== Lists & Results =====
  function refreshLists(){
    nodeList.innerHTML = nodes.map(n =>
      `<div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
         <span>Node ${n.id}: (${n.x.toFixed(1)}, ${n.y.toFixed(1)}), bc=${n.bc}, Fx=${n.Fx}, Fy=${n.Fy}, M=${n.M}, Kx=${n.Kx}, Ky=${n.Ky}</span>
         <button class="ghost" data-del-node="${n.id}" title="Delete node">✖</button>
       </div>`
    ).join('') || '<div class="hint">No nodes yet.</div>';

    memberList.innerHTML = members.map(m =>
      `<div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
         <span>Member ${m.id} [${m.label||''}]: n${m.n1}–n${m.n2} | E=${fmt(m.E)} A=${fmt(m.A)} I=${fmt(m.I)} S=${fmt(m.S)} c=${fmt(m.c)} wd=${fmt(m.wd)} qx=${fmt(m.qix)}→${fmt(m.qjx)} qy=${fmt(m.qiy)}→${fmt(m.qjy)} ${m.release_i?'| rel iθ':''} ${m.release_j?'| rel jθ':''}</span>
         <button class="ghost" data-del-member="${m.id}" title="Delete member">✖</button>
       </div>`
    ).join('') || '<div class="hint">No members yet.</div>';
  }
  const fmt = v => (v===0 || isNaN(v)) ? '0' : String(v);

  nodeList.addEventListener('click', (e)=>{
    const btn = e.target.closest('[data-del-node]');
    if (!btn) return;
    const id = parseInt(btn.getAttribute('data-del-node'),10);
    deleteNodeWithMembers(id);
  });

  memberList.addEventListener('click', (e)=>{
    const btn = e.target.closest('[data-del-member]');
    if (!btn) return;
    const id = parseInt(btn.getAttribute('data-del-member'),10);
    deleteMember(id);
  });

  function showResults(primaryRes){
    resultList.innerHTML = primaryRes.map(r =>
      `<div>Node ${r.id}: ux=${r.ux}, uy=${r.uy}, θ=${r.th}</div>`
    ).join('') || '<div class="hint">Solve to see displacements.</div>';
  }

  // ===== Kickoff =====
  setActiveGroup(modeBtns,'btnDraw');
  setActiveGroup(viewBtns,'viewGeom');
  refreshLists();
  draw();
})();
</script>
</body>
</html>
